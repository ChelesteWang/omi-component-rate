// node_modules/omi/dist/omi.esm.js
function getGlobal() {
  if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
    return self || window || global || function() {
      return this;
    }();
  }
  return global;
}
var options = {
  store: null,
  root: getGlobal(),
  mapping: {},
  isMultiStore: false,
  ignoreAttrs: false
};
(function() {
  if (window.Reflect === void 0 || window.customElements === void 0 || window.customElements.hasOwnProperty("polyfillWrapFlushCallback")) {
    return;
  }
  var BuiltInHTMLElement = HTMLElement;
  window.HTMLElement = function HTMLElement2() {
    return Reflect.construct(BuiltInHTMLElement, [], this.constructor);
  };
  HTMLElement.prototype = BuiltInHTMLElement.prototype;
  HTMLElement.prototype.constructor = HTMLElement;
  Object.setPrototypeOf(HTMLElement, BuiltInHTMLElement);
})();
function cssToDom(css) {
  var node = document.createElement("style");
  node.textContent = css;
  return node;
}
function camelCase(str) {
  return str.replace(/-(\w)/g, function($2, $1) {
    return $1.toUpperCase();
  });
}
function Fragment(props) {
  return props.children;
}
function extend(obj, props) {
  for (var i in props) {
    obj[i] = props[i];
  }
  return obj;
}
function applyRef(ref, value) {
  if (ref != null) {
    if (typeof ref == "function")
      ref(value);
    else
      ref.current = value;
  }
}
var defer = typeof Promise == "function" ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;
function isArray(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
}
function getUse(data, paths, out, name) {
  var obj = [];
  paths.forEach(function(path, index) {
    var isPath = typeof path === "string";
    if (isPath) {
      obj[index] = getTargetByPath(data, path);
    } else {
      var key = Object.keys(path)[0];
      var value = path[key];
      if (typeof value === "string") {
        obj[index] = getTargetByPath(data, value);
      } else {
        var tempPath = value[0];
        if (typeof tempPath === "string") {
          var tempVal = getTargetByPath(data, tempPath);
          obj[index] = value[1] ? value[1](tempVal) : tempVal;
        } else {
          var args = [];
          tempPath.forEach(function(path2) {
            args.push(getTargetByPath(data, path2));
          });
          obj[index] = value[1].apply(null, args);
        }
      }
      obj[key] = obj[index];
    }
  });
  if (out)
    out[name] = obj;
  return obj;
}
function pathToArr(path) {
  if (typeof path !== "string" || !path)
    return [];
  return path.replace(/]/g, "").replace(/\[/g, ".").split(".");
}
function getTargetByPath(origin, path) {
  var arr = pathToArr(path);
  var current = origin;
  for (var i = 0, len = arr.length; i < len; i++) {
    current = current[arr[i]];
  }
  return current;
}
var hyphenateRE = /\B([A-Z])/g;
function hyphenate(str) {
  return str.replace(hyphenateRE, "-$1").toLowerCase();
}
function getValByPath(path, current) {
  var arr = pathToArr(path);
  arr.forEach(function(prop) {
    current = current[prop];
  });
  return current;
}
function getPath(obj, out, name) {
  var result = {};
  obj.forEach(function(item) {
    if (typeof item === "string") {
      result[item] = true;
    } else {
      var tempPath = item[Object.keys(item)[0]];
      if (typeof tempPath === "string") {
        result[tempPath] = true;
      } else {
        if (typeof tempPath[0] === "string") {
          result[tempPath[0]] = true;
        } else {
          tempPath[0].forEach(function(path) {
            return result[path] = true;
          });
        }
      }
    }
  });
  if (out)
    out[name] = result;
  return result;
}
function removeItem(item, arr) {
  if (!arr)
    return;
  for (var i = 0, len = arr.length; i < len; i++) {
    if (arr[i] === item) {
      arr.splice(i, 1);
      break;
    }
  }
}
var stack = [];
function h(nodeName, attributes) {
  var children = [], lastSimple, child, simple, i;
  for (i = arguments.length; i-- > 2; ) {
    stack.push(arguments[i]);
  }
  if (attributes && attributes.children != null) {
    if (!stack.length)
      stack.push(attributes.children);
    delete attributes.children;
  }
  while (stack.length) {
    if ((child = stack.pop()) && child.pop !== void 0) {
      for (i = child.length; i--; ) {
        stack.push(child[i]);
      }
    } else {
      if (typeof child === "boolean")
        child = null;
      if (simple = typeof nodeName !== "function") {
        if (child == null)
          child = "";
        else if (typeof child === "number")
          child = String(child);
        else if (typeof child !== "string")
          simple = false;
      }
      if (simple && lastSimple) {
        children[children.length - 1] += child;
      } else if (children.length === 0) {
        children = [child];
      } else {
        children.push(child);
      }
      lastSimple = simple;
    }
  }
  if (nodeName === Fragment) {
    return children;
  }
  var p = {
    nodeName,
    children,
    attributes: attributes == null ? void 0 : attributes,
    key: attributes == null ? void 0 : attributes.key
  };
  if (options.vnode !== void 0)
    options.vnode(p);
  return p;
}
var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function isSameNodeType(node, vnode, hydrating2) {
  if (typeof vnode === "string" || typeof vnode === "number") {
    return node.splitText !== void 0;
  }
  if (typeof vnode.nodeName === "string") {
    return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
  } else if (typeof vnode.nodeName === "function") {
    return options.mapping[node.nodeName.toLowerCase()] === vnode.nodeName;
  }
  return hydrating2 || node._componentConstructor === vnode.nodeName;
}
function isNamedNode(node, nodeName) {
  return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
}
var extension = {};
function extend$1(name, handler) {
  extension["o-" + name] = handler;
}
function set(origin, path, value) {
  var arr = pathToArr(path);
  var current = origin;
  for (var i = 0, len = arr.length; i < len; i++) {
    if (i === len - 1) {
      current[arr[i]] = value;
    } else {
      current = current[arr[i]];
    }
  }
}
function get(origin, path) {
  var arr = pathToArr(path);
  var current = origin;
  for (var i = 0, len = arr.length; i < len; i++) {
    current = current[arr[i]];
  }
  return current;
}
function eventProxy(e) {
  return this._listeners[e.type](e);
}
function bind(el, type, handler) {
  el._listeners = el._listeners || {};
  el._listeners[type] = handler;
  el.addEventListener(type, eventProxy);
}
function unbind(el, type) {
  el.removeEventListener(type, eventProxy);
}
function createNode(nodeName, isSvg) {
  var node = isSvg ? document.createElementNS("http://www.w3.org/2000/svg", nodeName) : document.createElement(nodeName);
  node.normalizedNodeName = nodeName;
  return node;
}
function removeNode(node) {
  var parentNode = node.parentNode;
  if (parentNode)
    parentNode.removeChild(node);
}
function setAccessor(node, name, old, value, isSvg, component) {
  if (name === "className")
    name = "class";
  if (name[0] == "o" && name[1] == "-") {
    if (extension[name]) {
      extension[name](node, value, component);
    }
  } else if (name === "key") {
  } else if (name === "ref") {
    applyRef(old, null);
    applyRef(value, node);
  } else if (name === "class" && !isSvg) {
    node.className = value || "";
  } else if (name === "style") {
    if (!value || typeof value === "string" || typeof old === "string") {
      node.style.cssText = value || "";
    }
    if (value && typeof value === "object") {
      if (typeof old !== "string") {
        for (var i in old) {
          if (!(i in value))
            node.style[i] = "";
        }
      }
      for (var i in value) {
        node.style[i] = typeof value[i] === "number" && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + "px" : value[i];
      }
    }
  } else if (name === "dangerouslySetInnerHTML") {
    if (value)
      node.innerHTML = value.__html || "";
  } else if (name[0] == "_" && name[1] == "o" && name[2] == "n" && node.constructor.is === "WeElement") {
    bindEvent(node, name.replace("_", ""), value, old);
  } else if (name[0] == "o" && name[1] == "n") {
    bindEvent(node, name, value, old);
  } else if (node.nodeName === "INPUT" && name === "value") {
    node[name] = value == null ? "" : value;
  } else if (name !== "list" && name !== "type" && name !== "css" && !isSvg && name in node && value !== "") {
    try {
      node[name] = value == null ? "" : value;
    } catch (e) {
    }
    if ((value == null || value === false) && name != "spellcheck")
      node.pureRemoveAttribute ? node.pureRemoveAttribute(name) : node.removeAttribute(name);
  } else {
    var ns = isSvg && name !== (name = name.replace(/^xlink:?/, ""));
    if (value == null || value === false) {
      if (ns)
        node.removeAttributeNS("http://www.w3.org/1999/xlink", name.toLowerCase());
      else
        node.pureRemoveAttribute ? node.pureRemoveAttribute(name) : node.removeAttribute(name);
    } else if (typeof value !== "function") {
      if (ns) {
        node.setAttributeNS("http://www.w3.org/1999/xlink", name.toLowerCase(), value);
      } else {
        node.pureSetAttribute ? node.pureSetAttribute(name, value) : node.setAttribute(name, value);
      }
    }
  }
}
function eventProxy$1(e) {
  return this._listeners[e.type](options.event && options.event(e) || e);
}
function bindEvent(node, name, value, old) {
  var useCapture = name !== (name = name.replace(/Capture$/, ""));
  var nameLower = name.toLowerCase();
  name = (nameLower in node ? nameLower : name).slice(2);
  if (value) {
    if (!old) {
      node.addEventListener(name, eventProxy$1, useCapture);
    }
  } else {
    node.removeEventListener(name, eventProxy$1, useCapture);
  }
  (node._listeners || (node._listeners = {}))[name] = value;
}
var diffLevel = 0;
var isSvgMode = false;
var hydrating = false;
function diff(dom, vnode, parent, component, updateSelf) {
  if (!dom && !vnode)
    return;
  var ret;
  if (!diffLevel++) {
    isSvgMode = parent != null && parent.ownerSVGElement !== void 0;
    hydrating = dom != null && !("prevProps" in dom);
  }
  if (vnode && vnode.nodeName === Fragment) {
    vnode = vnode.children;
  }
  if (isArray(vnode)) {
    if (parent) {
      innerDiffNode(parent, vnode, hydrating, component, updateSelf);
    } else {
      ret = [];
      vnode.forEach(function(item, index) {
        var ele = idiff(index === 0 ? dom : null, item, component, updateSelf);
        ret.push(ele);
      });
    }
  } else {
    if (isArray(dom)) {
      dom.forEach(function(one, index) {
        if (index === 0) {
          ret = idiff(one, vnode, component, updateSelf);
        } else {
          recollectNodeTree(one, false);
        }
      });
    } else {
      ret = idiff(dom, vnode, component, updateSelf);
    }
    if (parent && ret.parentNode !== parent)
      parent.appendChild(ret);
  }
  if (!--diffLevel) {
    hydrating = false;
  }
  return ret;
}
function idiff(dom, vnode, component, updateSelf) {
  if (dom && vnode && dom.props) {
    dom.props.children = vnode.children;
  }
  var out = dom, prevSvgMode = isSvgMode;
  if (vnode == null || typeof vnode === "boolean")
    vnode = "";
  if (typeof vnode === "string" || typeof vnode === "number") {
    if (dom && dom.splitText !== void 0 && dom.parentNode && (!dom._component || component)) {
      if (dom.nodeValue != vnode) {
        dom.nodeValue = vnode;
      }
    } else {
      out = document.createTextNode(vnode);
      if (dom) {
        if (dom.parentNode)
          dom.parentNode.replaceChild(out, dom);
        recollectNodeTree(dom, true);
      }
    }
    out["prevProps"] = true;
    return out;
  }
  var vnodeName = vnode.nodeName;
  if (typeof vnodeName === "function") {
    for (var key in options.mapping) {
      if (options.mapping[key] === vnodeName) {
        vnodeName = key;
        vnode.nodeName = key;
        break;
      }
    }
  }
  isSvgMode = vnodeName === "svg" ? true : vnodeName === "foreignObject" ? false : isSvgMode;
  vnodeName = String(vnodeName);
  if (!dom || !isNamedNode(dom, vnodeName)) {
    out = createNode(vnodeName, isSvgMode);
    if (dom) {
      while (dom.firstChild) {
        out.appendChild(dom.firstChild);
      }
      if (dom.parentNode)
        dom.parentNode.replaceChild(out, dom);
      recollectNodeTree(dom, true);
    }
  }
  var fc = out.firstChild, props = out["prevProps"], vchildren = vnode.children;
  if (props == null) {
    props = out["prevProps"] = {};
    for (var a = out.attributes, i = a.length; i--; ) {
      props[a[i].name] = a[i].value;
    }
  }
  if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === "string" && fc != null && fc.splitText !== void 0 && fc.nextSibling == null) {
    if (fc.nodeValue != vchildren[0]) {
      fc.nodeValue = vchildren[0];
    }
  } else if (vchildren && vchildren.length || fc != null) {
    if (!(out.constructor.is == "WeElement" && out.constructor.noSlot)) {
      innerDiffNode(out, vchildren, hydrating || props.dangerouslySetInnerHTML != null, component, updateSelf);
    }
  }
  diffAttributes(out, vnode.attributes, props, component, updateSelf);
  if (out.props) {
    out.props.children = vnode.children;
  }
  isSvgMode = prevSvgMode;
  return out;
}
function innerDiffNode(dom, vchildren, isHydrating, component, updateSelf) {
  var originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren ? vchildren.length : 0, j, c, f, vchild, child;
  if (len !== 0) {
    for (var i = 0; i < len; i++) {
      var _child = originalChildren[i], props = _child["prevProps"], key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
      if (key != null) {
        keyedLen++;
        keyed[key] = _child;
      } else if (props || (_child.splitText !== void 0 ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
        children[childrenLen++] = _child;
      }
    }
  }
  if (vlen !== 0) {
    for (var i = 0; i < vlen; i++) {
      vchild = vchildren[i];
      child = null;
      var key = vchild.key;
      if (key != null) {
        if (keyedLen && keyed[key] !== void 0) {
          child = keyed[key];
          keyed[key] = void 0;
          keyedLen--;
        }
      } else if (!child && min < childrenLen) {
        for (j = min; j < childrenLen; j++) {
          if (children[j] !== void 0 && isSameNodeType(c = children[j], vchild, isHydrating)) {
            child = c;
            children[j] = void 0;
            if (j === childrenLen - 1)
              childrenLen--;
            if (j === min)
              min++;
            break;
          }
        }
      }
      child = idiff(child, vchild, component, updateSelf);
      f = originalChildren[i];
      if (child && child !== dom && child !== f) {
        if (f == null) {
          dom.appendChild(child);
        } else if (child === f.nextSibling) {
          removeNode(f);
        } else {
          dom.insertBefore(child, f);
        }
      }
    }
  }
  if (keyedLen) {
    for (var i in keyed) {
      if (keyed[i] !== void 0)
        recollectNodeTree(keyed[i], false);
    }
  }
  while (min <= childrenLen) {
    if ((child = children[childrenLen--]) !== void 0)
      recollectNodeTree(child, false);
  }
}
function recollectNodeTree(node, unmountOnly) {
  if (node["prevProps"] != null && node["prevProps"].ref) {
    if (typeof node["prevProps"].ref === "function") {
      node["prevProps"].ref(null);
    } else if (node["prevProps"].ref.current) {
      node["prevProps"].ref.current = null;
    }
  }
  if (unmountOnly === false || node["prevProps"] == null) {
    removeNode(node);
  }
  removeChildren(node);
}
function removeChildren(node) {
  node = node.lastChild;
  while (node) {
    var next = node.previousSibling;
    recollectNodeTree(node, true);
    node = next;
  }
}
function diffAttributes(dom, attrs, old, component, updateSelf) {
  var name;
  var isWeElement = dom.update;
  var oldClone;
  if (dom.receiveProps) {
    oldClone = Object.assign({}, old);
  }
  for (name in old) {
    if (!(attrs && attrs[name] != null) && old[name] != null) {
      setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode, component);
      if (isWeElement) {
        delete dom.props[name];
      }
    }
  }
  for (name in attrs) {
    if (isWeElement && typeof attrs[name] === "object" && name !== "ref") {
      if (name === "style") {
        setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode, component);
      }
      var ccName = camelCase(name);
      dom.props[ccName] = old[ccName] = attrs[name];
    } else if (name !== "children" && (!(name in old) || attrs[name] !== (name === "value" || name === "checked" ? dom[name] : old[name]))) {
      setAccessor(dom, name, old[name], attrs[name], isSvgMode, component);
      if (dom.nodeName.indexOf("-") !== -1) {
        dom.props = dom.props || {};
        var _ccName = camelCase(name);
        dom.props[_ccName] = old[_ccName] = attrs[name];
      } else {
        old[name] = attrs[name];
      }
    }
  }
  if (isWeElement && !updateSelf && dom.parentNode) {
    if (dom.receiveProps(dom.props, oldClone) !== false) {
      dom.update();
    }
  }
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var id = 0;
var WeElement = function(_HTMLElement) {
  _inherits(WeElement2, _HTMLElement);
  function WeElement2() {
    _classCallCheck(this, WeElement2);
    var _this = _possibleConstructorReturn(this, _HTMLElement.call(this));
    _this.props = Object.assign({}, _this.constructor.defaultProps, _this.props);
    _this.elementId = id++;
    _this.computed = {};
    _this.isInstalled = false;
    return _this;
  }
  WeElement2.prototype.connectedCallback = function connectedCallback() {
    var p = this.parentNode;
    while (p && !this.store) {
      this.store = p.store;
      p = p.parentNode || p.host;
    }
    this.attrsToProps();
    if (this.props.use) {
      this.use = this.props.use;
    }
    if (this.props.useSelf) {
      this.use = this.props.useSelf;
    }
    if (this.use) {
      var use = typeof this.use === "function" ? this.use() : this.use;
      if (options.isMultiStore) {
        var _updatePath = {};
        var using = {};
        for (var storeName in use) {
          _updatePath[storeName] = {};
          using[storeName] = {};
          getPath(use[storeName], _updatePath, storeName);
          getUse(this.store[storeName].data, use[storeName], using, storeName);
          this.store[storeName].instances.push(this);
        }
        this.using = using;
        this._updatePath = _updatePath;
      } else {
        this._updatePath = getPath(use);
        this.using = getUse(this.store.data, use);
        this.store.instances.push(this);
      }
    }
    if (this.useSelf) {
      var _use = typeof this.useSelf === "function" ? this.useSelf() : this.useSelf;
      if (options.isMultiStore) {
        var _updatePath2 = {};
        var _using = {};
        for (var _storeName in _use) {
          getPath(_use[_storeName], _updatePath2, _storeName);
          getUse(this.store[_storeName].data, _use[_storeName], _using, _storeName);
          this.store[_storeName].updateSelfInstances.push(this);
        }
        this.usingSelf = _using;
        this._updateSelfPath = _updatePath2;
      } else {
        this._updateSelfPath = getPath(_use);
        this.usingSelf = getUse(this.store.data, _use);
        this.store.updateSelfInstances.push(this);
      }
    }
    if (this.compute) {
      for (var key in this.compute) {
        this.computed[key] = this.compute[key].call(options.isMultiStore ? this.store : this.store.data);
      }
    }
    this.beforeInstall();
    this.install();
    this.afterInstall();
    var shadowRoot;
    if (this.constructor.isLightDom) {
      shadowRoot = this;
    } else {
      if (!this.shadowRoot) {
        shadowRoot = this.attachShadow({
          mode: "open"
        });
      } else {
        shadowRoot = this.shadowRoot;
        var fc;
        while (fc = shadowRoot.firstChild) {
          shadowRoot.removeChild(fc);
        }
      }
    }
    var css = this.constructor.css;
    if (css) {
      if (typeof css === "string") {
        var styleSheet = new CSSStyleSheet();
        styleSheet.replaceSync(css);
        shadowRoot.adoptedStyleSheets = [styleSheet];
      } else if (Object.prototype.toString.call(css) === "[object Array]") {
        var styleSheets = [];
        css.forEach(function(styleSheet2) {
          if (typeof styleSheet2 === "string") {
            var adoptedStyleSheet = new CSSStyleSheet();
            adoptedStyleSheet.replaceSync(styleSheet2);
            styleSheets.push(adoptedStyleSheet);
          } else {
            styleSheets.push(styleSheet2);
          }
          shadowRoot.adoptedStyleSheets = styleSheets;
        });
      } else {
        shadowRoot.adoptedStyleSheets = [css];
      }
    }
    this.beforeRender();
    options.afterInstall && options.afterInstall(this);
    var rendered = this.render(this.props, this.store);
    this.rootNode = diff(null, rendered, null, this);
    this.rendered();
    if (this.css) {
      shadowRoot.appendChild(cssToDom(typeof this.css === "function" ? this.css() : this.css));
    }
    if (this.props.css) {
      this._customStyleElement = cssToDom(this.props.css);
      this._customStyleContent = this.props.css;
      shadowRoot.appendChild(this._customStyleElement);
    }
    if (isArray(this.rootNode)) {
      this.rootNode.forEach(function(item) {
        shadowRoot.appendChild(item);
      });
    } else {
      this.rootNode && shadowRoot.appendChild(this.rootNode);
    }
    this.installed();
    this.isInstalled = true;
  };
  WeElement2.prototype.disconnectedCallback = function disconnectedCallback() {
    this.uninstall();
    this.isInstalled = false;
    if (this.store) {
      if (options.isMultiStore) {
        for (var key in this.store) {
          var current = this.store[key];
          removeItem(this, current.instances);
          removeItem(this, current.updateSelfInstances);
        }
      } else {
        removeItem(this, this.store.instances);
        removeItem(this, this.store.updateSelfInstances);
      }
    }
  };
  WeElement2.prototype.update = function update2(ignoreAttrs, updateSelf) {
    this._willUpdate = true;
    this.beforeUpdate();
    this.beforeRender();
    if (this._customStyleContent != this.props.css) {
      this._customStyleContent = this.props.css;
      this._customStyleElement.textContent = this._customStyleContent;
    }
    this.attrsToProps(ignoreAttrs);
    var rendered = this.render(this.props, this.store);
    this.rendered();
    this.rootNode = diff(this.rootNode, rendered, this.constructor.isLightDom ? this : this.shadowRoot, this, updateSelf);
    this._willUpdate = false;
    this.updated();
  };
  WeElement2.prototype.forceUpdate = function forceUpdate() {
    this.update(true);
  };
  WeElement2.prototype.updateProps = function updateProps(obj) {
    var _this2 = this;
    Object.keys(obj).forEach(function(key) {
      _this2.props[key] = obj[key];
      if (_this2.prevProps) {
        _this2.prevProps[key] = obj[key];
      }
    });
    this.forceUpdate();
  };
  WeElement2.prototype.updateSelf = function updateSelf(ignoreAttrs) {
    this.update(ignoreAttrs, true);
  };
  WeElement2.prototype.removeAttribute = function removeAttribute(key) {
    _HTMLElement.prototype.removeAttribute.call(this, key);
    this.isInstalled && this.update();
  };
  WeElement2.prototype.setAttribute = function setAttribute(key, val) {
    if (val && typeof val === "object") {
      _HTMLElement.prototype.setAttribute.call(this, key, JSON.stringify(val));
    } else {
      _HTMLElement.prototype.setAttribute.call(this, key, val);
    }
    this.isInstalled && this.update();
  };
  WeElement2.prototype.pureRemoveAttribute = function pureRemoveAttribute(key) {
    _HTMLElement.prototype.removeAttribute.call(this, key);
  };
  WeElement2.prototype.pureSetAttribute = function pureSetAttribute(key, val) {
    _HTMLElement.prototype.setAttribute.call(this, key, val);
  };
  WeElement2.prototype.attrsToProps = function attrsToProps(ignoreAttrs) {
    if (options.ignoreAttrs || ignoreAttrs || this.store && this.store.ignoreAttrs)
      return;
    var ele = this;
    ele.props["css"] = ele.getAttribute("css");
    var attrs = this.constructor.propTypes;
    if (!attrs)
      return;
    Object.keys(attrs).forEach(function(key) {
      var type = attrs[key];
      var val = ele.getAttribute(hyphenate(key));
      if (val !== null) {
        switch (type) {
          case String:
            ele.props[key] = val;
            break;
          case Number:
            ele.props[key] = Number(val);
            break;
          case Boolean:
            if (val === "false" || val === "0") {
              ele.props[key] = false;
            } else {
              ele.props[key] = true;
            }
            break;
          case Array:
          case Object:
            if (val[0] === ":") {
              ele.props[key] = getValByPath(val.substr(1), Omi.$);
            } else {
              ele.props[key] = JSON.parse(val.replace(/(['"])?([a-zA-Z0-9_-]+)(['"])?:([^\/])/g, '"$2":$4').replace(/'([\s\S]*?)'/g, '"$1"').replace(/,(\s*})/g, "$1"));
            }
            break;
        }
      } else {
        if (ele.constructor.defaultProps && ele.constructor.defaultProps.hasOwnProperty(key)) {
          ele.props[key] = ele.constructor.defaultProps[key];
        } else {
          ele.props[key] = null;
        }
      }
    });
  };
  WeElement2.prototype.fire = function fire(name, data) {
    this.dispatchEvent(new CustomEvent(name, {
      detail: data
    }));
  };
  WeElement2.prototype.beforeInstall = function beforeInstall() {
  };
  WeElement2.prototype.install = function install() {
  };
  WeElement2.prototype.afterInstall = function afterInstall() {
  };
  WeElement2.prototype.installed = function installed() {
  };
  WeElement2.prototype.uninstall = function uninstall() {
  };
  WeElement2.prototype.beforeUpdate = function beforeUpdate() {
  };
  WeElement2.prototype.updated = function updated() {
  };
  WeElement2.prototype.beforeRender = function beforeRender() {
  };
  WeElement2.prototype.rendered = function rendered() {
  };
  WeElement2.prototype.receiveProps = function receiveProps() {
  };
  return WeElement2;
}(HTMLElement);
WeElement.is = "WeElement";
var JSONPatcherProxy = function() {
  function deepClone(obj) {
    switch (typeof obj) {
      case "object":
        return JSON.parse(JSON.stringify(obj));
      case "undefined":
        return null;
      default:
        return obj;
    }
  }
  JSONPatcherProxy2.deepClone = deepClone;
  function escapePathComponent(str) {
    if (str.indexOf("/") == -1 && str.indexOf("~") == -1)
      return str;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  JSONPatcherProxy2.escapePathComponent = escapePathComponent;
  function findObjectPath(instance, obj) {
    var pathComponents = [];
    var parentAndPath = instance.parenthoodMap.get(obj);
    while (parentAndPath && parentAndPath.path) {
      pathComponents.unshift(parentAndPath.path);
      parentAndPath = instance.parenthoodMap.get(parentAndPath.parent);
    }
    if (pathComponents.length) {
      var path = pathComponents.join("/");
      return "/" + path;
    }
    return "";
  }
  function setTrap(instance, target, key, newValue) {
    var parentPath = findObjectPath(instance, target);
    var destinationPropKey = parentPath + "/" + escapePathComponent(key);
    if (instance.proxifiedObjectsMap.has(newValue)) {
      var newValueOriginalObject = instance.proxifiedObjectsMap.get(newValue);
      instance.parenthoodMap.set(newValueOriginalObject.originalObject, {
        parent: target,
        path: key
      });
    }
    var revokableInstance = instance.proxifiedObjectsMap.get(newValue);
    if (revokableInstance && !instance.isProxifyingTreeNow) {
      revokableInstance.inherited = true;
    }
    if (newValue && typeof newValue == "object" && !instance.proxifiedObjectsMap.has(newValue)) {
      instance.parenthoodMap.set(newValue, {
        parent: target,
        path: key
      });
      newValue = instance._proxifyObjectTreeRecursively(target, newValue, key);
    }
    var operation = {
      op: "remove",
      path: destinationPropKey
    };
    if (typeof newValue == "undefined") {
      if (!Array.isArray(target) && !target.hasOwnProperty(key)) {
        return Reflect.set(target, key, newValue);
      }
      if (Array.isArray(target)) {
        operation.op = "replace", operation.value = null;
      }
      var oldValue = instance.proxifiedObjectsMap.get(target[key]);
      if (oldValue) {
        instance.parenthoodMap.delete(target[key]);
        instance.disableTrapsForProxy(oldValue);
        instance.proxifiedObjectsMap.delete(oldValue);
      }
    } else {
      if (Array.isArray(target) && !Number.isInteger(+key.toString())) {
        if (key != "length") {
          console.warn("JSONPatcherProxy noticed a non-integer prop was set for an array. This will not emit a patch");
        }
        return Reflect.set(target, key, newValue);
      }
      operation.op = "add";
      if (target.hasOwnProperty(key)) {
        if (typeof target[key] !== "undefined" || Array.isArray(target)) {
          operation.op = "replace";
        }
      }
      operation.value = newValue;
    }
    operation.oldValue = target[key];
    var reflectionResult = Reflect.set(target, key, newValue);
    instance.defaultCallback(operation);
    return reflectionResult;
  }
  function deleteTrap(instance, target, key) {
    if (typeof target[key] !== "undefined") {
      var parentPath = findObjectPath(instance, target);
      var destinationPropKey = parentPath + "/" + escapePathComponent(key);
      var revokableProxyInstance = instance.proxifiedObjectsMap.get(target[key]);
      if (revokableProxyInstance) {
        if (revokableProxyInstance.inherited) {
          revokableProxyInstance.inherited = false;
        } else {
          instance.parenthoodMap.delete(revokableProxyInstance.originalObject);
          instance.disableTrapsForProxy(revokableProxyInstance);
          instance.proxifiedObjectsMap.delete(target[key]);
        }
      }
      var reflectionResult = Reflect.deleteProperty(target, key);
      instance.defaultCallback({
        op: "remove",
        path: destinationPropKey
      });
      return reflectionResult;
    }
  }
  function resume() {
    var _this = this;
    this.defaultCallback = function(operation) {
      _this.isRecording && _this.patches.push(operation);
      _this.userCallback && _this.userCallback(operation);
    };
    this.isObserving = true;
  }
  function pause() {
    this.defaultCallback = function() {
    };
    this.isObserving = false;
  }
  function JSONPatcherProxy2(root, showDetachedWarning) {
    this.isProxifyingTreeNow = false;
    this.isObserving = false;
    this.proxifiedObjectsMap = new Map();
    this.parenthoodMap = new Map();
    if (typeof showDetachedWarning !== "boolean") {
      showDetachedWarning = true;
    }
    this.showDetachedWarning = showDetachedWarning;
    this.originalObject = root;
    this.cachedProxy = null;
    this.isRecording = false;
    this.userCallback;
    this.resume = resume.bind(this);
    this.pause = pause.bind(this);
  }
  JSONPatcherProxy2.prototype.generateProxyAtPath = function(parent, obj, path) {
    var _this2 = this;
    if (!obj) {
      return obj;
    }
    var traps = {
      set: function set2(target, key, value, receiver) {
        return setTrap(_this2, target, key, value, receiver);
      },
      deleteProperty: function deleteProperty(target, key) {
        return deleteTrap(_this2, target, key);
      }
    };
    var revocableInstance = Proxy.revocable(obj, traps);
    revocableInstance.trapsInstance = traps;
    revocableInstance.originalObject = obj;
    this.parenthoodMap.set(obj, { parent, path });
    this.proxifiedObjectsMap.set(revocableInstance.proxy, revocableInstance);
    return revocableInstance.proxy;
  };
  JSONPatcherProxy2.prototype._proxifyObjectTreeRecursively = function(parent, root, path) {
    for (var key in root) {
      if (root.hasOwnProperty(key)) {
        if (root[key] instanceof Object) {
          root[key] = this._proxifyObjectTreeRecursively(root, root[key], escapePathComponent(key));
        }
      }
    }
    return this.generateProxyAtPath(parent, root, path);
  };
  JSONPatcherProxy2.prototype.proxifyObjectTree = function(root) {
    this.pause();
    this.isProxifyingTreeNow = true;
    var proxifiedObject = this._proxifyObjectTreeRecursively(void 0, root, "");
    this.isProxifyingTreeNow = false;
    this.resume();
    return proxifiedObject;
  };
  JSONPatcherProxy2.prototype.disableTrapsForProxy = function(revokableProxyInstance) {
    if (this.showDetachedWarning) {
      var message = "You're accessing an object that is detached from the observedObject tree, see https://github.com/Palindrom/JSONPatcherProxy#detached-objects";
      revokableProxyInstance.trapsInstance.set = function(targetObject, propKey, newValue) {
        console.warn(message);
        return Reflect.set(targetObject, propKey, newValue);
      };
      revokableProxyInstance.trapsInstance.set = function(targetObject, propKey, newValue) {
        console.warn(message);
        return Reflect.set(targetObject, propKey, newValue);
      };
      revokableProxyInstance.trapsInstance.deleteProperty = function(targetObject, propKey) {
        return Reflect.deleteProperty(targetObject, propKey);
      };
    } else {
      delete revokableProxyInstance.trapsInstance.set;
      delete revokableProxyInstance.trapsInstance.get;
      delete revokableProxyInstance.trapsInstance.deleteProperty;
    }
  };
  JSONPatcherProxy2.prototype.observe = function(record, callback) {
    if (!record && !callback) {
      throw new Error("You need to either record changes or pass a callback");
    }
    this.isRecording = record;
    this.userCallback = callback;
    if (record)
      this.patches = [];
    this.cachedProxy = this.proxifyObjectTree(this.originalObject);
    return this.cachedProxy;
  };
  JSONPatcherProxy2.prototype.generate = function() {
    if (!this.isRecording) {
      throw new Error("You should set record to true to get patches later");
    }
    return this.patches.splice(0, this.patches.length);
  };
  JSONPatcherProxy2.prototype.revoke = function() {
    this.proxifiedObjectsMap.forEach(function(el) {
      el.revoke();
    });
  };
  JSONPatcherProxy2.prototype.disableTraps = function() {
    this.proxifiedObjectsMap.forEach(this.disableTrapsForProxy, this);
  };
  return JSONPatcherProxy2;
}();
function render(vnode, parent, store) {
  parent = typeof parent === "string" ? document.querySelector(parent) : parent;
  if (store) {
    if (store.data) {
      observeStore(store);
    }
    parent.store = store;
  }
  return diff(null, vnode, parent, false);
}
function observeStore(store, key) {
  store.instances = [];
  store.updateSelfInstances = [];
  extendStoreUpdate(store, key);
  store.data = new JSONPatcherProxy(store.data).observe(false, function(patch) {
    var patchs = {};
    if (patch.op === "remove") {
      var kv = getArrayPatch(patch.path, store);
      patchs[kv.k] = kv.v;
      update(patchs, store);
    } else {
      var key2 = fixPath(patch.path);
      patchs[key2] = patch.value;
      update(patchs, store);
    }
  });
}
function update(patch, store) {
  store.update(patch);
}
function extendStoreUpdate(store, key) {
  store.update = function(patch) {
    if (Object.keys(patch).length > 0) {
      this.instances.forEach(function(instance) {
        compute(instance, key);
        if (key) {
          if (instance._updatePath && instance._updatePath[key] && needUpdate(patch, instance._updatePath[key])) {
            if (instance.use) {
              getUse(store.data, (typeof instance.use === "function" ? instance.use() : instance.use)[key], instance.using, key);
            }
            instance.update();
          }
        } else {
          if (instance._updatePath && needUpdate(patch, instance._updatePath)) {
            if (instance.use) {
              instance.using = getUse(store.data, typeof instance.use === "function" ? instance.use() : instance.use);
            }
            instance.update();
          }
        }
      });
      this.updateSelfInstances.forEach(function(instance) {
        compute(instance, key);
        if (key) {
          if (instance._updateSelfPath && instance._updateSelfPath[key] && needUpdate(patch, instance._updateSelfPath[key])) {
            if (instance.useSelf) {
              getUse(store.data, (typeof instance.useSelf === "function" ? instance.useSelf() : instance.useSelf)[key], instance.usingSelf, key);
            }
            instance.updateSelf();
          }
        } else {
          if (instance._updateSelfPath && needUpdate(patch, instance._updateSelfPath)) {
            instance.usingSelf = getUse(store.data, typeof instance.useSelf === "function" ? instance.useSelf() : instance.useSelf);
            instance.updateSelf();
          }
        }
      });
      this.onChange && this.onChange(patch);
    }
  };
}
function compute(instance, isMultiStore) {
  if (instance.compute) {
    for (var ck in instance.compute) {
      instance.computed[ck] = instance.compute[ck].call(isMultiStore ? instance.store : instance.store.data);
    }
  }
}
function needUpdate(diffResult, updatePath) {
  for (var keyA in diffResult) {
    if (updatePath[keyA]) {
      return true;
    }
    for (var keyB in updatePath) {
      if (includePath(keyA, keyB)) {
        return true;
      }
    }
  }
  return false;
}
function includePath(pathA, pathB) {
  if (pathA.indexOf(pathB) === 0) {
    var next = pathA.substr(pathB.length, 1);
    if (next === "[" || next === ".") {
      return true;
    }
  }
  return false;
}
function fixPath(path) {
  var mpPath = "";
  var arr = path.replace("/", "").split("/");
  arr.forEach(function(item, index) {
    if (index) {
      if (isNaN(Number(item))) {
        mpPath += "." + item;
      } else {
        mpPath += "[" + item + "]";
      }
    } else {
      mpPath += item;
    }
  });
  return mpPath;
}
function getArrayPatch(path, store) {
  var arr = path.replace("/", "").split("/");
  var current = store.data[arr[0]];
  for (var i = 1, len = arr.length; i < len - 1; i++) {
    current = current[arr[i]];
  }
  return {
    k: fixArrPath(path),
    v: current
  };
}
function fixArrPath(path) {
  var mpPath = "";
  var arr = path.replace("/", "").split("/");
  var len = arr.length;
  arr.forEach(function(item, index) {
    if (index < len - 1) {
      if (index) {
        if (isNaN(Number(item))) {
          mpPath += "." + item;
        } else {
          mpPath += "[" + item + "]";
        }
      } else {
        mpPath += item;
      }
    }
  });
  return mpPath;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn$1(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var storeHelpers = ["use", "useSelf"];
function define(name, ctor, config) {
  if (customElements.get(name)) {
    return;
  }
  if (options.mapping[name]) {
    return;
  }
  if (ctor.is === "WeElement") {
    customElements.define(name, ctor);
    options.mapping[name] = ctor;
  } else {
    if (typeof config === "string") {
      config = { css: config };
    } else {
      config = config || {};
    }
    var Ele = function(_WeElement) {
      _inherits$1(Ele2, _WeElement);
      function Ele2() {
        var _temp, _this, _ret;
        _classCallCheck$1(this, Ele2);
        for (var _len = arguments.length, args = Array(_len), key2 = 0; key2 < _len; key2++) {
          args[key2] = arguments[key2];
        }
        return _ret = (_temp = (_this = _possibleConstructorReturn$1(this, _WeElement.call.apply(_WeElement, [this].concat(args))), _this), _this.compute = config.compute, _temp), _possibleConstructorReturn$1(_this, _ret);
      }
      Ele2.prototype.render = function render2() {
        return ctor.call(this, this);
      };
      return Ele2;
    }(WeElement);
    Ele.css = config.css;
    Ele.propTypes = config.propTypes;
    Ele.defaultProps = config.defaultProps;
    Ele.isLightDom = config.isLightDom;
    var _loop = function _loop2(key2) {
      if (typeof config[key2] === "function") {
        Ele.prototype[key2] = function() {
          return config[key2].apply(this, arguments);
        };
      }
    };
    for (var key in config) {
      _loop(key);
    }
    storeHelpers.forEach(function(func) {
      if (config[func] && config[func] !== "function") {
        Ele.prototype[func] = function() {
          return config[func];
        };
      }
    });
    customElements.define(name, Ele);
    options.mapping[name] = Ele;
  }
}
function tag(name) {
  return function(target) {
    define(name, target);
  };
}
function cloneElement(vnode, props) {
  return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
}
function getHost(ele) {
  var p = ele.parentNode;
  while (p) {
    if (p.host) {
      return p.host;
    } else if (p.shadowRoot && p.shadowRoot.host) {
      return p.shadowRoot.host;
    } else {
      p = p.parentNode;
    }
  }
}
function rpx(css) {
  return css.replace(/([1-9]\d*|0)(\.\d*)*rpx/g, function(a, b) {
    return window.innerWidth * Number(b) / 750 + "px";
  });
}
var hasOwn = {}.hasOwnProperty;
function classNames() {
  var classes = [];
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    if (!arg)
      continue;
    var argType = typeof arg;
    if (argType === "string" || argType === "number") {
      classes.push(arg);
    } else if (Array.isArray(arg) && arg.length) {
      var inner = classNames.apply(null, arg);
      if (inner) {
        classes.push(inner);
      }
    } else if (argType === "object") {
      for (var key in arg) {
        if (hasOwn.call(arg, key) && arg[key]) {
          classes.push(key);
        }
      }
    }
  }
  return classes.join(" ");
}
function extractClass() {
  var _Array$prototype$slic = Array.prototype.slice.call(arguments, 0), props = _Array$prototype$slic[0], args = _Array$prototype$slic.slice(1);
  if (props.class) {
    args.unshift(props.class);
    delete props.class;
  } else if (props.className) {
    args.unshift(props.className);
    delete props.className;
  }
  if (args.length > 0) {
    return { class: classNames.apply(null, args) };
  }
}
function o(obj) {
  return JSON.stringify(obj);
}
(function() {
  if ("adoptedStyleSheets" in document) {
    return;
  }
  var hasShadyCss = "ShadyCSS" in window && !ShadyCSS.nativeShadow;
  var bootstrapper = document.implementation.createHTMLDocument("boot");
  var closedShadowRootRegistry = new WeakMap();
  var _DOMException = typeof DOMException === "object" ? Error : DOMException;
  var defineProperty = Object.defineProperty;
  var forEach = Array.prototype.forEach;
  var importPattern = /@import.+?;?$/gm;
  function rejectImports(contents) {
    var _contents = contents.replace(importPattern, "");
    if (_contents !== contents) {
      console.warn("@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418");
    }
    return _contents.trim();
  }
  function clearRules(sheet) {
    for (var i = 0; i < sheet.cssRules.length; i++) {
      sheet.deleteRule(0);
    }
  }
  function insertAllRules(from, to) {
    forEach.call(from.cssRules, function(rule, i) {
      to.insertRule(rule.cssText, i);
    });
  }
  function isElementConnected(element) {
    return "isConnected" in element ? element.isConnected : document.contains(element);
  }
  function unique(arr) {
    return arr.filter(function(value, index) {
      return arr.indexOf(value) === index;
    });
  }
  function diff2(arr1, arr2) {
    return arr1.filter(function(value) {
      return arr2.indexOf(value) === -1;
    });
  }
  function removeNode2(node) {
    node.parentNode.removeChild(node);
  }
  function getShadowRoot(element) {
    return element.shadowRoot || closedShadowRootRegistry.get(element);
  }
  var cssStyleSheetMethods = [
    "addImport",
    "addPageRule",
    "addRule",
    "deleteRule",
    "insertRule",
    "removeImport",
    "removeRule"
  ];
  var NonConstructedStyleSheet = CSSStyleSheet;
  var nonConstructedProto = NonConstructedStyleSheet.prototype;
  nonConstructedProto.replace = function() {
    return Promise.reject(new _DOMException("Can't call replace on non-constructed CSSStyleSheets."));
  };
  nonConstructedProto.replaceSync = function() {
    throw new _DOMException("Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.");
  };
  function isCSSStyleSheetInstance(instance) {
    return typeof instance === "object" ? proto$2.isPrototypeOf(instance) || nonConstructedProto.isPrototypeOf(instance) : false;
  }
  function isNonConstructedStyleSheetInstance(instance) {
    return typeof instance === "object" ? nonConstructedProto.isPrototypeOf(instance) : false;
  }
  var $basicStyleSheet = new WeakMap();
  var $locations = new WeakMap();
  var $adoptersByLocation = new WeakMap();
  function addAdopterLocation(sheet, location) {
    var adopter = document.createElement("style");
    $adoptersByLocation.get(sheet).set(location, adopter);
    $locations.get(sheet).push(location);
    return adopter;
  }
  function getAdopterByLocation(sheet, location) {
    return $adoptersByLocation.get(sheet).get(location);
  }
  function removeAdopterLocation(sheet, location) {
    $adoptersByLocation.get(sheet).delete(location);
    $locations.set(sheet, $locations.get(sheet).filter(function(_location) {
      return _location !== location;
    }));
  }
  function restyleAdopter(sheet, adopter) {
    requestAnimationFrame(function() {
      clearRules(adopter.sheet);
      insertAllRules($basicStyleSheet.get(sheet), adopter.sheet);
    });
  }
  function checkInvocationCorrectness(self2) {
    if (!$basicStyleSheet.has(self2)) {
      throw new TypeError("Illegal invocation");
    }
  }
  function ConstructedStyleSheet() {
    var self2 = this;
    var style = document.createElement("style");
    bootstrapper.body.appendChild(style);
    $basicStyleSheet.set(self2, style.sheet);
    $locations.set(self2, []);
    $adoptersByLocation.set(self2, new WeakMap());
  }
  var proto$2 = ConstructedStyleSheet.prototype;
  proto$2.replace = function replace(contents) {
    try {
      this.replaceSync(contents);
      return Promise.resolve(this);
    } catch (e) {
      return Promise.reject(e);
    }
  };
  proto$2.replaceSync = function replaceSync(contents) {
    checkInvocationCorrectness(this);
    if (typeof contents === "string") {
      var self_1 = this;
      var style = $basicStyleSheet.get(self_1).ownerNode;
      style.textContent = rejectImports(contents);
      $basicStyleSheet.set(self_1, style.sheet);
      $locations.get(self_1).forEach(function(location) {
        if (location.isConnected()) {
          restyleAdopter(self_1, getAdopterByLocation(self_1, location));
        }
      });
    }
  };
  defineProperty(proto$2, "cssRules", {
    configurable: true,
    enumerable: true,
    get: function cssRules() {
      checkInvocationCorrectness(this);
      return $basicStyleSheet.get(this).cssRules;
    }
  });
  cssStyleSheetMethods.forEach(function(method) {
    proto$2[method] = function() {
      var self2 = this;
      checkInvocationCorrectness(self2);
      var args = arguments;
      var basic = $basicStyleSheet.get(self2);
      var locations2 = $locations.get(self2);
      var result = basic[method].apply(basic, args);
      locations2.forEach(function(location) {
        if (location.isConnected()) {
          var sheet = getAdopterByLocation(self2, location).sheet;
          sheet[method].apply(sheet, args);
        }
      });
      return result;
    };
  });
  defineProperty(ConstructedStyleSheet, Symbol.hasInstance, {
    configurable: true,
    value: isCSSStyleSheetInstance
  });
  var defaultObserverOptions = {
    childList: true,
    subtree: true
  };
  var locations = new WeakMap();
  function getAssociatedLocation(element) {
    var location = locations.get(element);
    if (!location) {
      location = new Location(element);
      locations.set(element, location);
    }
    return location;
  }
  function attachAdoptedStyleSheetProperty(constructor) {
    defineProperty(constructor.prototype, "adoptedStyleSheets", {
      configurable: true,
      enumerable: true,
      get: function() {
        return getAssociatedLocation(this).sheets;
      },
      set: function(sheets) {
        getAssociatedLocation(this).update(sheets);
      }
    });
  }
  function traverseWebComponents(node, callback) {
    var iter = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, function(foundNode) {
      return getShadowRoot(foundNode) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
    }, null, false);
    for (var next = void 0; next = iter.nextNode(); ) {
      callback(getShadowRoot(next));
    }
  }
  var $element = new WeakMap();
  var $uniqueSheets = new WeakMap();
  var $observer = new WeakMap();
  function isExistingAdopter(self2, element) {
    return element instanceof HTMLStyleElement && $uniqueSheets.get(self2).some(function(sheet) {
      return getAdopterByLocation(sheet, self2);
    });
  }
  function getAdopterContainer(self2) {
    var element = $element.get(self2);
    return element instanceof Document ? element.body : element;
  }
  function adopt(self2) {
    var styleList = document.createDocumentFragment();
    var sheets = $uniqueSheets.get(self2);
    var observer = $observer.get(self2);
    var container = getAdopterContainer(self2);
    observer.disconnect();
    sheets.forEach(function(sheet) {
      styleList.appendChild(getAdopterByLocation(sheet, self2) || addAdopterLocation(sheet, self2));
    });
    container.insertBefore(styleList, null);
    observer.observe(container, defaultObserverOptions);
    sheets.forEach(function(sheet) {
      restyleAdopter(sheet, getAdopterByLocation(sheet, self2));
    });
  }
  function Location(element) {
    var self2 = this;
    self2.sheets = [];
    $element.set(self2, element);
    $uniqueSheets.set(self2, []);
    $observer.set(self2, new MutationObserver(function(mutations, observer) {
      if (!document) {
        observer.disconnect();
        return;
      }
      mutations.forEach(function(mutation) {
        if (!hasShadyCss) {
          forEach.call(mutation.addedNodes, function(node) {
            if (!(node instanceof Element)) {
              return;
            }
            traverseWebComponents(node, function(root) {
              getAssociatedLocation(root).connect();
            });
          });
        }
        forEach.call(mutation.removedNodes, function(node) {
          if (!(node instanceof Element)) {
            return;
          }
          if (isExistingAdopter(self2, node)) {
            adopt(self2);
          }
          if (!hasShadyCss) {
            traverseWebComponents(node, function(root) {
              getAssociatedLocation(root).disconnect();
            });
          }
        });
      });
    }));
  }
  var proto$1 = Location.prototype;
  proto$1.isConnected = function isConnected() {
    var element = $element.get(this);
    return element instanceof Document ? element.readyState !== "loading" : isElementConnected(element.host);
  };
  proto$1.connect = function connect() {
    var container = getAdopterContainer(this);
    $observer.get(this).observe(container, defaultObserverOptions);
    if ($uniqueSheets.get(this).length > 0) {
      adopt(this);
    }
    traverseWebComponents(container, function(root) {
      getAssociatedLocation(root).connect();
    });
  };
  proto$1.disconnect = function disconnect() {
    $observer.get(this).disconnect();
  };
  proto$1.update = function update2(sheets) {
    var self2 = this;
    var locationType = $element.get(self2) === document ? "Document" : "ShadowRoot";
    if (!Array.isArray(sheets)) {
      throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Iterator getter is not callable.");
    }
    if (!sheets.every(isCSSStyleSheetInstance)) {
      throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Failed to convert value to 'CSSStyleSheet'");
    }
    if (sheets.some(isNonConstructedStyleSheetInstance)) {
      throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + locationType + ": Can't adopt non-constructed stylesheets");
    }
    self2.sheets = sheets;
    var oldUniqueSheets = $uniqueSheets.get(self2);
    var uniqueSheets = unique(sheets);
    var removedSheets = diff2(oldUniqueSheets, uniqueSheets);
    removedSheets.forEach(function(sheet) {
      removeNode2(getAdopterByLocation(sheet, self2));
      removeAdopterLocation(sheet, self2);
    });
    $uniqueSheets.set(self2, uniqueSheets);
    if (self2.isConnected() && uniqueSheets.length > 0) {
      adopt(self2);
    }
  };
  window.CSSStyleSheet = ConstructedStyleSheet;
  attachAdoptedStyleSheetProperty(Document);
  if ("ShadowRoot" in window) {
    attachAdoptedStyleSheetProperty(ShadowRoot);
    var proto = Element.prototype;
    var attach_1 = proto.attachShadow;
    proto.attachShadow = function attachShadow(init) {
      var root = attach_1.call(this, init);
      if (init.mode === "closed") {
        closedShadowRootRegistry.set(this, root);
      }
      return root;
    };
  }
  var documentLocation = getAssociatedLocation(document);
  if (documentLocation.isConnected()) {
    documentLocation.connect();
  } else {
    document.addEventListener("DOMContentLoaded", documentLocation.connect.bind(documentLocation));
  }
})();
h.f = Fragment;
function createRef() {
  return {};
}
var $ = {};
var Component = WeElement;
var defineElement = define;
var elements = options.mapping;
var omi = {
  tag,
  WeElement,
  Component,
  render,
  h,
  createElement: h,
  options,
  define,
  cloneElement,
  getHost,
  rpx,
  defineElement,
  classNames,
  extractClass,
  createRef,
  o,
  elements,
  $,
  extend: extend$1,
  get,
  set,
  bind,
  unbind,
  JSONProxy: JSONPatcherProxy
};
options.root.Omi = omi;
options.root.omi = omi;
options.root.Omi.version = "6.19.23";
var omi_esm_default = omi;

export {
  options,
  h,
  extend$1,
  set,
  get,
  bind,
  unbind,
  WeElement,
  JSONPatcherProxy,
  render,
  define,
  tag,
  cloneElement,
  getHost,
  rpx,
  classNames,
  extractClass,
  o,
  createRef,
  $,
  Component,
  defineElement,
  elements,
  omi_esm_default
};
/*!
 * https://github.com/Palindrom/JSONPatcherProxy
 * (c) 2017 Starcounter
 * MIT license
 */
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
//# sourceMappingURL=chunk-OG6SUC3N.js.map
